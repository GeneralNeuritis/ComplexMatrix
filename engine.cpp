

#include  "engine.h"


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// IMPLEMENTATION(ptr_t<type>)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


template <class type> ptr_t<type>::ptr_t() : 
  _local(false), 
  _ptr(0) 
{

}

template <class type> ptr_t<type>::ptr_t(type* __ptr) : 
	_local(false), 
	_ptr(__ptr) 
{

}

template <class type> bool ptr_t<type>::init(type* __ptr) 
{ 
	if(!_local && !_ptr) {
		_ptr = __ptr;
		return true;
	}
	return false;
}

template <class type> type* ptr_t<type>::ptr(type* __ptr) 
{ 
	if(!_local){ _ptr = __ptr; } 
		return _ptr;
}

template <class type> bool ptr_t<type>::local() const
{ 
	return _local;
}

template <class type> type* ptr_t<type>::ptr() const
{ 
	return _ptr;
}

template <class type> ptr_t<type>::~ptr_t(){ 
  if(_local) {
  	delete _ptr; _ptr = 0; _local = false;
  }
}

template <class type> ptr_t<type> ptr_t<type>::share() const {
	ptr_t<type> that;
		that._local = false;
		that._ptr = _ptr;
	return that;
}


template class ptr_t<float>;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION(array_t<type>)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


template <class type> array_t<type>::array_t() : 
	_size(0) 
{ 
}


template <class type> array_t<type>::array_t(unsigned int __size) : 
	_size(__size) 
{ 
	init(__size);
}


template <class type> array_t<type>::array_t(type* __ptr, unsigned int __size) :
	_size(__size)
{
	init(__ptr, __size);
}


template <class type> bool array_t<type>::init(unsigned int __size) 
{ 
	if(!_ptr && __size)
	{
		_ptr = new type[__size];
		if(_ptr)
		{
			_local = true;
			_size = __size;
			return false; // no error
		}
	}
	return true; // error
}


template <class type> bool array_t<type>::init(type *__ptr, unsigned int __size) 
{ 
	if(!_ptr && __size)
	{
		_local = false;
		_ptr = __ptr; 
		_size = __size;
		return false;	
	}
	return true;
}


template <class type> unsigned int array_t<type>::size() const 
{ 
	return _size; 
}


template <class type> bool array_t<type>::copy( const array_t<type> &rvalue ) {
  if(_size==rvalue._size) {
    for(unsigned int i=0;i<_size;i++) {
      _ptr[i] = rvalue.read(i);
    }
    return false; // if(b.copy(a)){  }
  }
  return true; // if(!b.copy(a)){  }
}
template <class type> const type array_t<type>::read(unsigned int offset) const {
  return _ptr[offset%_size];
}
template <class type> type &array_t<type>::operator [] (unsigned int offset) { 
  return _ptr[offset%_size];
}


template class array_t<float>;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION(array2d_t<type>)


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <class type> array2d_t<type>::array2d_t() : 
	_height(0), 
	_width(0) 
{ 
	array_t<type>(); 
}


template <class type> array2d_t<type>::array2d_t(unsigned int __height, unsigned int __width) :
	array_t<type>(_height * _width),
  _height(__height), 
  _width(__width) 
{
  
}


template <class type> array2d_t<type>::array2d_t(type *__ptr, unsigned int __height, unsigned int __width) :
  array_t<type>(__ptr, __height*__width),
  _height(__height), 
  _width(__width) 
{
  
}


template <class type> bool array2d_t<type>::init(unsigned int __height, unsigned int __width) {
  if( !_ptr && !(_height*_width)) {
    _height = __height; _width = __width;
    return array_t<type>::init(_height*_width);    
  }
  return true;
}


template <class type> bool array2d_t<type>::init(type *__ptr, unsigned int __height, unsigned int __width) {
  if( !_ptr && !(_height*_width) ) {
    _height = __height; _width = __width;
    return array_t<type>::init(__ptr, _height*_width); 
  }
  return true;
}


template <class type> unsigned int array2d_t<type>::height() const 
{ 
	return _height; 
}


template <class type> unsigned int array2d_t<type>::width() const
{ 
	return _width;
}


template <class type> bool array2d_t<type>::copy( const array2d_t<type> &rvalue ) 
{
  if(_height==rvalue._height && _width==rvalue._width) {
    for(unsigned int i=0;i<_size;i++) {
      _ptr[i] = rvalue.array_t<type>::read(i);
    }
    return false;
  }
  return true;
}


template <class type> const type array2d_t<type>::read(unsigned int x, unsigned int y) const
{
  return _ptr[(x%_height)*_width + (y%_width)];
}



template <class type> array_t<type> array2d_t<type>::operator [] (unsigned int offset) {
  array_t<type> row(&_ptr[(offset%_height)*_width], _width);
  return row;
}

template <class type> array_t<type *> array2d_t<type>::col(unsigned int _col)
{
	array_t<type *> column(_height); _col%=_width; 
	for(unsigned i=0;i<_height;i++)
	{
		column[i] = &_ptr[_col + i*_width];
	}
	return column;
}

template <class type> array_t<type> array2d_t<type>::read_col(unsigned int _col) const
{
	array_t<type> column(_height); _col%=_width; 
	for(unsigned i=0;i<_height;i++)
	{
		column[i] = array_t<type>::read(_col + i*_width);
	}
	return column;
}


template class array2d_t<float>;


// IMPLEMENTATION(square2d_t<type>)

template <class type> square2d_t<type>::square2d_t(){ }
template <class type> square2d_t<type>::square2d_t(unsigned int __size) { array2d_t<type>(__size,__size); }
template <class type> square2d_t<type>::square2d_t(type* __ptr, unsigned int __size) { array2d_t<type>(__ptr,__size,__size); }

template <class type> bool square2d_t<type>::init(unsigned int __size){ return array2d_t<type>::init(__size, __size); }
template <class type> bool square2d_t<type>::init(type* __ptr, unsigned int __size){ return array2d_t<type>::init(__ptr, __size,__size); }

template class square2d_t<float>;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// IMPLEMENTATION(vector_t<scalar>)


template <class scalar> vector_t<scalar>::vector_t(){ }
template <class scalar> vector_t<scalar>::vector_t(unsigned int __size) { this->array_t<scalar>::init(__size); this->op_nul(); }
template <class scalar> vector_t<scalar>::vector_t(scalar* __ptr, unsigned int __size) { this->array_t<scalar>::init(__ptr,__size); this->op_nul(); }

template <class scalar> bool vector_t<scalar>::init(unsigned int __size)
{ 
	if( !this->array_t<scalar>::init(__size) ) {
		op_nul();
		return true;
	}
	return false;
}

template <class scalar> bool vector_t<scalar>::init(scalar* __ptr, unsigned int __size){ 
	if( !this->array_t<scalar>::init(__ptr, __size) ) {
		op_nul();
		return true;
	}
	return false;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


template <class scalar> vector_t<scalar> vector_t<scalar>::op_add( vector_t<scalar> dest, const vector_t<scalar> value )
{
  if(dest._size==value._size) {
    for(unsigned int i=0;i<_size;i++) {
      dest._ptr[i] += value.read(i);
    }
    return dest;
  }
  vector_t _null;
  	_null._local = false;
  	_null._ptr = (scalar*) 0;
  	_null._size = 0;
  return _null;
}

template <class scalar> vector_t<scalar> vector_t<scalar>::op_sub( vector_t<scalar> dest, const vector_t<scalar> value )
{
  if(dest._size==value._size) {
    for(unsigned int i=0;i<_size;i++) {
      dest._ptr[i] -= value.read(i);
    }
    return dest;
  }  
  vector_t _null;
  	_null._local = false;
  	_null._ptr = (scalar*) 0;
  	_null._size = 0;
  return _null;
}

template <class scalar> vector_t<scalar> vector_t<scalar>::op_mul( vector_t<scalar> dest, const scalar value )
{
  for(unsigned int i=0;i<_size;i++)
  { 
    dest._ptr[i] *= value;
  }
  return dest;
}

template <class scalar> vector_t<scalar> vector_t<scalar>::op_div( vector_t<scalar> dest, const scalar value )
{
  for(unsigned int i=0;i<_size;i++)
  { 
    _ptr[i] /= value; 
  }
  return dest;
}

template <class scalar> vector_t<scalar> vector_t<scalar>::op_dot( vector_t<scalar> dest, const vector_t<scalar> value )
{
  if(dest._size==value._size) {
    for(unsigned int i=0;i<_size;i++) {
      dest._ptr[i] *= value.read(i);
    }
    return dest;
  }  
  vector_t _null;
  	_null._local = false;
  	_null._ptr = (scalar*) 0;
  	_null._size = 0;
  return _null;
}

template <class scalar> vector_t<scalar> vector_t<scalar>::op_bar( vector_t<scalar> dest, const vector_t<scalar> value )
{
  if(dest._size==value._size) {
    for(unsigned int i=0;i<_size;i++) {
      dest._ptr[i] /= value.read(i);
    }
    return dest;
  }

  vector_t _null;
  	_null._local = false;
  	_null._ptr = (scalar*) 0;
  	_null._size = 0;
  return _null;
}

template <class scalar> bool vector_t<scalar>::op_equ(const vector_t<scalar> a, const vector_t<scalar> b) const
{
	if(a._size == b._size)
	{
		for(unsigned int i=0;i<_size;i++)
		{
			if( !(a._ptr[i] == b._ptr[i]) ) return false;
		}
		return true;
	} else return false;
}

template <class scalar> bool vector_t<scalar>::op_neq(const vector_t<scalar> a, const vector_t<scalar> b) const
{
	if(a._size == b._size)
	{
		for(unsigned int i=0;i<_size;i++)
		{
			if( !(a._ptr[i] == b._ptr[i]) ) return true;
		}
		return false;
	} else return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


template <class scalar> void vector_t<scalar>::op_neg()
{
	for(unsigned i = 0;i<_size;i++) { _ptr[i] = -_ptr[i]; }
}

template <class scalar> void vector_t<scalar>::op_nul()
{
	for(unsigned i = 0;i<_size;i++) { _ptr[i] -= _ptr[i]; }
}


template <class scalar> bool vector_t<scalar>::op_dotw_addb(scalar &dest, const vector_t<scalar> &inputs, const vector_t<scalar> &weights, const scalar &bias)
{
	if(inputs._size==weights._size)
	{
		scalar _dot; _dot-=_dot;
		for(unsigned i=0;i<inputs._size;i++){ // function call exists, skip it internally.
			_dot += weights.read(i) * inputs.read(i);
		}
		dest = _dot + bias;
		return false;
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <class scalar> vector_t<scalar> vector_t<scalar>::operator += ( const vector_t<scalar> &value )
{

	vector_t _share(_ptr, _size);
	_share._local = false;

	op_add(*this, value);
	return _share;
}

template <class scalar> vector_t<scalar> vector_t<scalar>::operator -= ( const vector_t<scalar> &value )
{
	vector_t _share(_ptr, _size);
	_share._local = false;

	op_sub(*this, value);
	return _share;
}

template <class scalar> vector_t<scalar> vector_t<scalar>::operator *= ( const vector_t<scalar> &value )
{
	vector_t _share(_ptr, _size);
	_share._local = false;

	op_dot(*this, value);
	return _share;
}

template <class scalar> vector_t<scalar> vector_t<scalar>::operator /= ( const vector_t<scalar> &value )
{
	vector_t _share(_ptr, _size);
	_share._local = false;

	op_bar(*this, value);
	return _share;
}

template <class scalar> vector_t<scalar> vector_t<scalar>::operator *= ( const scalar &value )
{
	vector_t _share(_ptr, _size);
	_share._local = false;

	op_mul(*this, value);
	return _share;
}

template <class scalar> vector_t<scalar> vector_t<scalar>::operator /= ( const scalar &value )
{
	vector_t _share(_ptr, _size);
	_share._local = false;

	op_div(*this, value);
	return _share;
}

template <class scalar> bool vector_t<scalar>::operator == ( const vector_t<scalar> &value ) const
{
	return op_equ(*this, value);
}

template <class scalar> bool vector_t<scalar>::operator != ( const vector_t<scalar> &value ) const
{
	return op_neq(*this, value);
}



template class vector_t<float>;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///  template <class scalar, unsigned int SIZE> vector_s<scalar, SIZE>::vector_s() : vector_t<scalar>( &value[0], SIZE ) { }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// IMPLEMENTATION(matrix_t<scalar>)


template <class scalar> matrix_t<scalar>::matrix_t(){ }
template <class scalar> matrix_t<scalar>::matrix_t(unsigned int __height, unsigned int __width) : array2d_t<scalar>(__height,__width) { }
template <class scalar> matrix_t<scalar>::matrix_t(scalar* __ptr, unsigned int __height, unsigned int __width) : array2d_t<scalar>(__ptr,__height,__width) { }

template <class scalar> bool matrix_t<scalar>::init(unsigned int __height, unsigned int __width)
{ 
	if( !array2d_t<scalar>::init(__height, __width) ) {
		op_nul();
		return true;
	}
	return false;
}

template <class scalar> bool matrix_t<scalar>::init(scalar* __ptr, unsigned int __height, unsigned int __width){ 
	if( !array2d_t<scalar>::init(__ptr, __height, __width) ) {
		op_nul();
		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


template <class scalar> matrix_t<scalar> matrix_t<scalar>::op_add( matrix_t<scalar> dest, const matrix_t<scalar> value )
{
  if(dest._size==value._size&&dest._height==value._height) {
    for(unsigned int i=0;i<_size;i++) {
      dest._ptr[i] += value.array_t<scalar>::read(i);
    }
    return dest;
  }
  matrix_t<scalar> _null;
  	_null._local = false;
  	_null._ptr = (scalar*) 0;
  	_null._size = 0;
  	_null._height = 0;
  	_null._width = 0;
  return _null;
}

template <class scalar> matrix_t<scalar> matrix_t<scalar>::op_sub( matrix_t<scalar> dest, const matrix_t<scalar> value )
{
  if(dest._size==value._size&&dest._height==value._height) {
    for(unsigned int i=0;i<_size;i++) {
      dest._ptr[i] -= value.array_t<scalar>::read(i);
    }
    return dest;
  }
  
  matrix_t<scalar> _null;
  	_null._local = false;
  	_null._ptr = (scalar*) 0;
  	_null._size = 0;
  	_null._height = 0;
  	_null._width = 0;
  return _null;
}

template <class scalar> matrix_t<scalar> matrix_t<scalar>::op_mul( matrix_t<scalar> dest, const scalar value )
{
  for(unsigned int i=0;i<_size;i++)
  { 
    dest._ptr[i] *= value;
  }
  return dest;
}

template <class scalar> matrix_t<scalar> matrix_t<scalar>::op_div( matrix_t<scalar> dest, const scalar value )
{
  for(unsigned int i=0;i<_size;i++)
  { 
    dest._ptr[i] /= value; 
  }
  return dest;
}

template <class scalar> matrix_t<scalar> matrix_t<scalar>::op_dot( matrix_t<scalar> dest, const matrix_t<scalar> value )
{
  if(dest._size==value._size&&dest._height==value._height) {
    for(unsigned int i=0;i<_size;i++) {
      dest._ptr[i] *= value.array_t<scalar>::read(i);
    }
    return dest;
  }
  matrix_t<scalar> _null;
  	_null._local = false;
  	_null._ptr = (scalar*) 0;
  	_null._size = 0;
  	_null._height = 0;
  	_null._width = 0;
  return _null;
}

template <class scalar> matrix_t<scalar> matrix_t<scalar>::op_bar( matrix_t<scalar> dest, const matrix_t<scalar> value )
{
  if(dest._size==value._size&&dest._height==value._height) {
    for(unsigned int i=0;i<_size;i++) {
      dest._ptr[i] /= value.array_t<scalar>::read(i);
    }
    return dest;
  }
  matrix_t<scalar> _null;
  	_null._local = false;
  	_null._ptr = (scalar*) 0;
  	_null._size = 0;
  	_null._height = 0;
  	_null._width = 0;
  return _null;
}



template <class scalar> bool matrix_t<scalar>::op_mult(matrix_t<scalar> &dest, const matrix_t<scalar> &left, const matrix_t<scalar> &right)
{
	if( left.width() == right.height() && left.height() == dest.height() && right.width() == dest.width() ){
		for(unsigned i=0; i<dest.height();i++) {
			for(unsigned j=0;j<dest.width();j++) {
				for(unsigned k=0;k<left.height();k++){
					dest[i][j] += left.read(i,k) * right.read(k,j);
				}
			}
		}
		return false;		
	}

	return true;
}


template <class scalar> bool matrix_t<scalar>::op_equ(const matrix_t<scalar> a, const matrix_t<scalar> b) const
{
	if(a._size==b._size&&a._height==b._height)
	{
		for(unsigned int i=0;i<_size;i++)
		{
			if( !(a._ptr[i] == b._ptr[i]) ) return false;
		}
		return true;
	} else return false;
}

template <class scalar> bool matrix_t<scalar>::op_neq(const matrix_t<scalar> a, const matrix_t<scalar> b) const
{
	if(a._size==b._size&&a._height==b._height)
	{
		for(unsigned int i=0;i<_size;i++)
		{
			if( !(a._ptr[i] == b._ptr[i]) ) return true;
		}
		return false;
	} else return true;
}

template <class scalar> void matrix_t<scalar>::op_nul()
{
	for(unsigned int i=0;i<_size;i++)
	{
		_ptr[i]-=_ptr[i];
	}
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <class scalar> matrix_t<scalar> matrix_t<scalar>::operator += ( const matrix_t<scalar> &value )
{
	op_add(*this, value);
	return *this;
}

template <class scalar> matrix_t<scalar> matrix_t<scalar>::operator -= ( const matrix_t<scalar> &value )
{
	op_sub(*this, value);
	return *this;
}

template <class scalar> matrix_t<scalar> matrix_t<scalar>::operator *= ( const matrix_t<scalar> &value )
{
	op_dot(*this, value);
	return *this;
}

template <class scalar> matrix_t<scalar> matrix_t<scalar>::operator /= ( const matrix_t<scalar> &value )
{
	op_bar(*this, value);
	return *this;
}

template <class scalar> matrix_t<scalar> matrix_t<scalar>::operator *= ( const scalar &value )
{
	op_mul(*this, value);
	return *this;
}

template <class scalar> matrix_t<scalar> matrix_t<scalar>::operator /= ( const scalar &value )
{
	op_div(*this, value);
	return *this;
}

template <class scalar> bool matrix_t<scalar>::operator == ( const matrix_t<scalar> &value ) const
{
	return op_equ(*this, value);
}

template <class scalar> bool matrix_t<scalar>::operator != ( const matrix_t<scalar> &value ) const
{
	return op_neq(*this, value);
}

template class matrix_t<float>;



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// template <class scalar, unsigned int HEIGHT, unsigned int WIDTH> matrix_s<scalar, HEIGHT, WIDTH>::matrix_s()  { this->init( &value[0][0], HEIGHT, WIDTH ); this->matrix_t<scalar>::op_nul(); }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*


template <class scalar, unsigned int WIDTH> scalar matrix_ss<scalar, WIDTH>::det(){
	scalar _det;
	scalar _product;

	
	_det -= _det;
	for(unsigned int i=0;i<WIDTH;i++){
		for(unsigned int j=0;j<WIDTH;j++) {
			_product = value[(i+j) % WIDTH][(i+j) % WIDTH];
			for(unsigned int k=1;k<WIDTH;k++)
			{
				_product*=value[(i+j+k) % WIDTH][(i+j) % WIDTH];
			}
			_det += _product;
		}
		for(unsigned int j=0;j<WIDTH;j++) {
			_product = value[(i+j) % WIDTH][(-i-j) % WIDTH];
			for(unsigned int k=1;k<WIDTH;k++)
			{
				_product*=value[(i+j+k) % WIDTH][(-i-j) % WIDTH];
			}
			_det -= _product;
		}
	}
	return _det;
}

template <class scalar> matrix3x3_t<scalar>::matrix3x3_t(){
	matrix_t<scalar>::init(&tensor.x.x, 3, 3);
}

*/


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef __unitint_h

template <class fpAccessType, class uintStorageType>
_unit_tt<fpAccessType, uintStorageType>::operator fpAccessType() {
  // defined on the closed unit interval over
  // continuum suggested by fpAccessType.
  return fpAccessType(item) / fpAccessType((1 << (8*sizeof(uintStorageType) - 1)));
}

template <class fpAccessType, class uintStorageType>
fpAccessType _unit_tt<fpAccessType, uintStorageType>::operator = (fpAccessType f) {
  if(0.0 <= f && f <= 1.0) {

    uintStorageType _f; _f = uintStorageType(f);
    fpAccessType __f = f - fpAccessType(_f);

    item = uintStorageType(     __f * fpAccessType((1 << (8*sizeof(uintStorageType) - 1)))     );
  }
  return f;
}

#endif

// IMPLEMENTATION(complex_t<scalar>)


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


template<class scalar> complex_t<scalar> complex_t<scalar>::_stack;
template<class scalar> quaternion_t<scalar> quaternion_t<scalar>::_stack;
template<class scalar> hamiltonian_t<scalar> hamiltonian_t<scalar>::_stack;

template<class scalar> quaternion_t<scalar> quaternion_t<scalar>::_op_stack;
template<class scalar> hamiltonian_t<scalar> hamiltonian_t<scalar>::_op_stack;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



template <class scalar> complex_t<scalar>::complex_t() {
  re -= re; im -= im;
}
template <class scalar> complex_t<scalar>::complex_t(scalar param) {
  re = param; im -= im;
}
template <class scalar> complex_t<scalar>::complex_t(scalar _re, scalar _im) {
  re = _re; im = _im;
}
template <class scalar> complex_t<scalar>::complex_t(const complex_t<scalar> &param) {
  re = param.re; im = param.im;
}

template <class scalar> scalar complex_t<scalar>::norm2() const {
  return re*re + im*im;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <class scalar> void complex_t<scalar>::op_add(complex_t<scalar> &dest, const complex_t<scalar> &rvalue) const {
  dest = {re + rvalue.re, im + rvalue.im};
}
template <class scalar> void complex_t<scalar>::op_sub(complex_t<scalar> &dest, const complex_t<scalar> &rvalue) const {
  dest = {re - rvalue.re, im - rvalue.im};
}
template <class scalar> void complex_t<scalar>::op_mul(complex_t<scalar> &dest, const scalar &rvalue) const {
  dest = {re * rvalue, im * rvalue};
}
template <class scalar> void complex_t<scalar>::op_div(complex_t<scalar> &dest, const scalar &rvalue) const {
  dest = {re / rvalue, im / rvalue};
}
template <class scalar> void complex_t<scalar>::op_mul(complex_t<scalar> &dest, const complex_t<scalar> &rvalue) const {
  dest = {re * rvalue.re - im * rvalue.im, re * rvalue.im + im * rvalue.re};
}
template <class scalar> void complex_t<scalar>::op_div(complex_t<scalar> &dest, const complex_t<scalar> &rvalue) const {
  scalar _norm2 = rvalue.norm2();
  dest = {(re * rvalue.re + im * rvalue.im) / _norm2, (im*rvalue.re - re*rvalue.im) / _norm2};
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



template <class scalar> complex_t<scalar> complex_t<scalar>::operator + (const complex_t<scalar> param) const {
  _stack = *this;
  op_add(_stack, param);
  return _stack;
}
template <class scalar> complex_t<scalar> complex_t<scalar>::operator - (const complex_t<scalar> param) const {
  _stack = *this;
  op_sub(_stack, param);
  return _stack;
}
template <class scalar> complex_t<scalar> complex_t<scalar>::operator * (const complex_t<scalar> param) const {
  _stack = *this;
  op_mul(_stack, param);
  return _stack;
}
template <class scalar> complex_t<scalar> complex_t<scalar>::operator / (const complex_t<scalar> param) const {
  _stack = *this;
  op_div(_stack, param);
  return _stack;
}
template <class scalar> complex_t<scalar> complex_t<scalar>::operator * (const scalar param) const {
  _stack = *this;
  op_mul(_stack, param);
  return _stack;
}
template <class scalar> complex_t<scalar> complex_t<scalar>::operator / (const scalar param) const {
  _stack = *this;
  op_div(_stack, param);
  return _stack;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



template <class scalar> complex_t<scalar> & complex_t<scalar>::operator += (const complex_t<scalar> param) {
  op_add(*this, param);
  return *this;
}
template <class scalar> complex_t<scalar> & complex_t<scalar>::operator -= (const complex_t<scalar> param) {
  op_sub(*this, param);
  return *this;
}
template <class scalar> complex_t<scalar> & complex_t<scalar>::operator *= (const complex_t<scalar> param) {
  op_mul(*this, param);
  return *this;
}
template <class scalar> complex_t<scalar> & complex_t<scalar>::operator /= (const complex_t<scalar> param) {
  op_div(*this, param);
  return *this;
}
template <class scalar> complex_t<scalar> & complex_t<scalar>::operator *= (const scalar param) {
  op_mul(*this, param);
  return *this;
}
template <class scalar> complex_t<scalar> & complex_t<scalar>::operator /= (const scalar param) {
  op_div(*this, param);
  return *this;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





template <class scalar> bool complex_t<scalar>::operator == (const complex_t<scalar> param) const {
  return re == param.re && im == param.im;
}
template <class scalar> bool complex_t<scalar>::operator != (const complex_t<scalar> param) const {
  return re != param.re || im != param.im;
}
template <class scalar> bool complex_t<scalar>::operator <= (const complex_t<scalar> param) const {
  return (norm2() <= param.norm2());
}
template <class scalar> bool complex_t<scalar>::operator >= (const complex_t<scalar> param) const {
  return (norm2() >= param.norm2());
}
template <class scalar> bool complex_t<scalar>::operator < (const complex_t<scalar> param) const {
  return (norm2() < param.norm2());
}
template <class scalar> bool complex_t<scalar>::operator > (const complex_t<scalar> param) const {
  return (norm2() > param.norm2());
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


template <class scalar> complex_t<scalar> complex_t<scalar>::operator - () const {
  return {-re, -im};
}
template <class scalar> complex_t<scalar> complex_t<scalar>::operator ~ () const {
  return {re, -im};  // no need to make a vector operation.
}
template <class scalar> complex_t<scalar> complex_t<scalar>::inv() const {
  return ~(*this)/norm2();
}

template <class scalar> vector_t<scalar> complex_t<scalar>::vector_cast() {
  return vector_t<scalar>(&re, 2);
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// IMPLEMENTATION(quaternion_t<scalar>)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


template <class scalar> quaternion_t<scalar>::quaternion_t() {
  w-=w;x-=x;y-=y;z-=z;
}
template <class scalar> quaternion_t<scalar>::quaternion_t( complex_t< complex_t<scalar> > nested ) {
  quaternion_t<scalar>(nested.re, nested.im);
}
template <class scalar> quaternion_t<scalar>::quaternion_t( complex_t<scalar> _re, complex_t<scalar> _im ) {
  quaternion_t<scalar>(_re.re, _re.im, _im.re, _im.im);
}
template <class scalar> quaternion_t<scalar>::quaternion_t(scalar _w, scalar _x, scalar _y, scalar _z) {
  w=_w;x=_x;y=_y;z=_z; 
}
template <class scalar> quaternion_t<scalar>::quaternion_t(const quaternion_t<scalar> &_value) {
  *this = _value;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


template <class scalar> scalar quaternion_t<scalar>::norm2() const {
  return w*w+x*x+y*y+z*z;
}

template <class scalar> void quaternion_t<scalar>::op_add(quaternion_t<scalar> &dest, const quaternion_t<scalar> &rvalue) const {
  dest = {w+rvalue.w, x+rvalue.x, y+rvalue.y, z+rvalue.z};
}

template <class scalar> void quaternion_t<scalar>::op_sub(quaternion_t<scalar> &dest, const quaternion_t<scalar> &rvalue) const {
  dest = {w-rvalue.w, x-rvalue.x, y-rvalue.y, z-rvalue.z};
}

template <class scalar> void quaternion_t<scalar>::op_add(quaternion_t<scalar> &dest, const complex_t<scalar> &rvalue) const {
  dest = {w+rvalue.re, x+rvalue.im, y, z};
}

template <class scalar> void quaternion_t<scalar>::op_sub(quaternion_t<scalar> &dest, const complex_t<scalar> &rvalue) const {
  dest = {w-rvalue.re, x-rvalue.im, y, z};
}

template <class scalar> void quaternion_t<scalar>::op_add(quaternion_t<scalar> &dest, const scalar &rvalue) const {
  dest = {w+rvalue, x, y, z};
}

template <class scalar> void quaternion_t<scalar>::op_sub(quaternion_t<scalar> &dest, const scalar &rvalue) const {
  dest = {w-rvalue, x, y, z};
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



template <class scalar> void quaternion_t<scalar>::op_mul(quaternion_t<scalar> &dest, const scalar &rvalue) const {
  dest = {w*rvalue, x*rvalue, y*rvalue, z*rvalue};
}

template <class scalar> void quaternion_t<scalar>::op_div(quaternion_t<scalar> &dest, const scalar &rvalue) const {
  dest = {w/rvalue, x/rvalue, y/rvalue, z/rvalue};
}

template <class scalar> void quaternion_t<scalar>::op_mul(quaternion_t<scalar> &dest, const complex_t<scalar> &rvalue) const {
  _op_stack = quaternion_t<scalar>(rvalue);
  op_mul(dest, _stack);
}

template <class scalar> void quaternion_t<scalar>::op_div(quaternion_t<scalar> &dest, const complex_t<scalar> &rvalue) const {
  _op_stack = quaternion_t<scalar>(rvalue.inv());
  op_mul(dest, _stack);
}


template <class scalar> void quaternion_t<scalar>::op_mul(quaternion_t<scalar> &dest, const quaternion_t<scalar> &rvalue) const {
  complex_t<complex_t<scalar>> _this = {{this->w, this->x},{this->y,this->z}};
  complex_t<complex_t<scalar>> _rvalue = {{rvalue.w, rvalue.x},{rvalue.y,rvalue.z}};
  complex_t<complex_t<scalar>> _dest;
  _dest.re = _this.re * _rvalue.re - (~(_rvalue.im) ) * _this.im;
  _dest.im = _rvalue.im * _this.re + _this.im * (~(_rvalue.im) );
  dest = {{_dest.re.re, _dest.re.im},{_dest.im.re, _dest.im.im}};
}

template <class scalar> void quaternion_t<scalar>::op_div(quaternion_t<scalar> &dest, const quaternion_t<scalar> &rvalue) const {
  _op_stack = rvalue.inv();
  op_mul( dest, _op_stack );
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



template <class scalar> quaternion_t<scalar> quaternion_t<scalar>::operator + ( const quaternion_t<scalar> param ) const {
  _stack = *this;
  op_add(_stack, param);
  return _stack;
}

template <class scalar> quaternion_t<scalar> quaternion_t<scalar>::operator - ( const quaternion_t<scalar> param ) const {
  _stack = *this;
  op_sub(_stack, param);
  return _stack;
}

template <class scalar> quaternion_t<scalar> & quaternion_t<scalar>::operator += ( const quaternion_t<scalar> param ) 
{
  op_add(*this, param);
  return *this;
}

template <class scalar> quaternion_t<scalar> & quaternion_t<scalar>::operator -= ( const quaternion_t<scalar> param )
{
  op_sub(*this, param);
  return *this;
}

template <class scalar> quaternion_t<scalar> quaternion_t<scalar>::operator + ( const complex_t<scalar> param ) const {
  _stack = *this;
  op_add(_stack, param);
  return _stack;
}

template <class scalar> quaternion_t<scalar> quaternion_t<scalar>::operator - ( const complex_t<scalar> param ) const {
  _stack = *this;
  op_sub(_stack, param);
  return _stack;
}

template <class scalar> quaternion_t<scalar> & quaternion_t<scalar>::operator += ( const complex_t<scalar> param ) 
{
  op_add(*this, param);
  return *this;
}

template <class scalar> quaternion_t<scalar> & quaternion_t<scalar>::operator -= ( const complex_t<scalar> param )
{
  op_sub(*this, param);
  return *this;
}

template <class scalar> quaternion_t<scalar> quaternion_t<scalar>::operator + ( const scalar param ) const {
  _stack = *this;
  op_add(_stack, param);
  return _stack;
}

template <class scalar> quaternion_t<scalar> quaternion_t<scalar>::operator - ( const scalar param ) const {
  _stack = *this;
  op_sub(_stack, param);
  return _stack;
}

template <class scalar> quaternion_t<scalar> & quaternion_t<scalar>::operator += ( const scalar param ) 
{
  op_add(*this, param);
  return *this;
}

template <class scalar> quaternion_t<scalar> & quaternion_t<scalar>::operator -= ( const scalar param )
{
  op_sub(*this, param);
  return *this;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


template <class scalar> quaternion_t<scalar> quaternion_t<scalar>::operator * ( const quaternion_t<scalar> param ) const {
  _stack = *this;
  op_mul(_stack, param);
  return _stack;
}

template <class scalar> quaternion_t<scalar> quaternion_t<scalar>::operator / ( const quaternion_t<scalar> param ) const {
  _stack = *this;
  op_div(_stack, param);
  return _stack;
}

template <class scalar> quaternion_t<scalar> & quaternion_t<scalar>::operator *= ( const quaternion_t<scalar> param ) 
{
  op_mul(*this, param);
  return *this;
}

template <class scalar> quaternion_t<scalar> & quaternion_t<scalar>::operator /= ( const quaternion_t<scalar> param )
{
  op_div(*this, param);
  return *this;
}

template <class scalar> quaternion_t<scalar> quaternion_t<scalar>::operator * ( const complex_t<scalar> param ) const {
  _stack = *this;
  op_mul(_stack, param);
  return _stack;
}

template <class scalar> quaternion_t<scalar> quaternion_t<scalar>::operator / ( const complex_t<scalar> param ) const {
  _stack = *this;
  op_div(_stack, param);
  return _stack;
}

template <class scalar> quaternion_t<scalar> & quaternion_t<scalar>::operator *= (const complex_t<scalar> param) 
{
  op_mul(*this, param);
  return *this;
}

template <class scalar> quaternion_t<scalar> & quaternion_t<scalar>::operator /= (const complex_t<scalar> param)
{
  op_div(*this, param);
  return *this;
}

template <class scalar> quaternion_t<scalar> quaternion_t<scalar>::operator * (const scalar param) const {
  _stack = *this;
  op_mul(_stack, param);
  return _stack;
}

template <class scalar> quaternion_t<scalar> quaternion_t<scalar>::operator / (const scalar param) const {
  _stack = *this;
  op_div(_stack, param);
  return _stack;
}

template <class scalar> quaternion_t<scalar> & quaternion_t<scalar>::operator *= (const scalar param) 
{
  op_mul(*this, param);
  return *this;
}

template <class scalar> quaternion_t<scalar> & quaternion_t<scalar>::operator /= (const scalar param)
{
  op_div(*this, param);
  return *this;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


template <class scalar> bool quaternion_t<scalar>::operator == (const quaternion_t<scalar> param) const {
  return (w==param.w)&&(x==param.x)&&(y==param.y)&&(z==param.z);
}
template <class scalar> bool quaternion_t<scalar>::operator != (const quaternion_t<scalar> param) const {
  return (w!=param.w)||(x!=param.x)||(y!=param.y)||(z!=param.z);
}
template <class scalar> bool quaternion_t<scalar>::operator <= (const quaternion_t<scalar> param) const {
  return (norm2() <= param.norm2());
}
template <class scalar> bool quaternion_t<scalar>::operator >= (const quaternion_t<scalar> param) const {
  return (norm2() >= param.norm2());
}
template <class scalar> bool quaternion_t<scalar>::operator < (const quaternion_t<scalar> param) const {
  return (norm2() < param.norm2());
}
template <class scalar> bool quaternion_t<scalar>::operator > (const quaternion_t<scalar> param) const {
  return (norm2() > param.norm2());
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



template <class scalar> quaternion_t<scalar> quaternion_t<scalar>::operator ~ () const {
  return {w, -x, -y, -z};
}

template <class scalar> quaternion_t<scalar> quaternion_t<scalar>::operator - () const {
  return {-w, -x, -y, -z};
}
template <class scalar> quaternion_t<scalar> quaternion_t<scalar>::inv() const {
  return ~(*this)/norm2();
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


template <class scalar> vector_t<scalar> quaternion_t<scalar>::vector_cast() {
  return vector_t<scalar>(&w, 4);
}

template <class scalar> complex_t<complex_t<scalar>> & quaternion_t<scalar>::complex_cast() {
  return reinterpret_cast< complex_t<complex_t<scalar>> &>(*this);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// IMPLEMENTATION(hamiltonian_t<scalar>)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


template <class scalar> hamiltonian_t<scalar>::hamiltonian_t() 
{ x-=x;y-=y;z-=z; }
template <class scalar> hamiltonian_t<scalar>::hamiltonian_t(scalar _x, scalar _y, scalar _z) 
{ x=_x;y=_y;z=_z; }
template <class scalar> hamiltonian_t<scalar>::hamiltonian_t(const hamiltonian_t<scalar> &that) 
{ *this = that; }
template <class scalar> scalar hamiltonian_t<scalar>::norm2() const
{ return x*x + y*y + z*z; }

template <class scalar> hamiltonian_t<scalar> hamiltonian_t<scalar>::operator - () const { return {-x,-y,-z}; }
template <class scalar> hamiltonian_t<scalar> hamiltonian_t<scalar>::inv() const { return -(*this)/norm2(); }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <class scalar> void hamiltonian_t<scalar>::op_add(hamiltonian_t<scalar> &dest, const hamiltonian_t<scalar> &rvalue) const {
  dest = {x + rvalue.x, y + rvalue.y, z + rvalue.z};
}
template <class scalar> void hamiltonian_t<scalar>::op_sub(hamiltonian_t<scalar> &dest, const hamiltonian_t<scalar> &rvalue) const {
  dest = {x - rvalue.x, y - rvalue.y, z - rvalue.z};
}
template <class scalar> void hamiltonian_t<scalar>::op_dot(hamiltonian_t<scalar> &dest, const hamiltonian_t<scalar> &rvalue) const {
  dest = {x * rvalue.x, y * rvalue.y, z * rvalue.z};
}
template <class scalar> void hamiltonian_t<scalar>::op_mul(hamiltonian_t<scalar> &dest, const scalar &rvalue) const {
  dest = {x * rvalue, y * rvalue, z * rvalue};
}
template <class scalar> void hamiltonian_t<scalar>::op_div(hamiltonian_t<scalar> &dest, const scalar &rvalue) const {
  dest = {x / rvalue, y / rvalue, z / rvalue};
}
template <class scalar> void hamiltonian_t<scalar>::op_mul(hamiltonian_t<scalar> &dest, const hamiltonian_t<scalar> &rvalue) const {
  dest = {y*rvalue.z-z*rvalue.y, z*rvalue.x-x*rvalue.z, x*rvalue.y-y*rvalue.x};
}
template <class scalar> void hamiltonian_t<scalar>::op_div(hamiltonian_t<scalar> &dest, const hamiltonian_t<scalar> &rvalue) const {
  _op_stack = rvalue.inv();
  op_mul(dest, _op_stack);
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



template <class scalar> hamiltonian_t<scalar> hamiltonian_t<scalar>::operator + (const hamiltonian_t<scalar> param) const {
  _stack = *this;
  op_add(_stack, param);
  return _stack;
}
template <class scalar> hamiltonian_t<scalar> hamiltonian_t<scalar>::operator - (const hamiltonian_t<scalar> param) const {
  _stack = *this;
  op_sub(_stack, param);
  return _stack;
}
template <class scalar> hamiltonian_t<scalar> hamiltonian_t<scalar>::stack_dot(const hamiltonian_t<scalar> param) const {
  _stack = *this;
  op_dot(_stack, param);
  return _stack;
}
template <class scalar> hamiltonian_t<scalar> hamiltonian_t<scalar>::operator * (const hamiltonian_t<scalar> param) const {
  _stack = *this;
  op_mul(_stack, param);
  return _stack;
}
template <class scalar> hamiltonian_t<scalar> hamiltonian_t<scalar>::operator / (const hamiltonian_t<scalar> param) const {
  _stack = *this;
  op_div(_stack, param);
  return _stack;
}
template <class scalar> hamiltonian_t<scalar> hamiltonian_t<scalar>::operator * (const scalar param) const {
  _stack = *this;
  op_mul(_stack, param);
  return _stack;
}
template <class scalar> hamiltonian_t<scalar> hamiltonian_t<scalar>::operator / (const scalar param) const {
  _stack = *this;
  op_div(_stack, param);
  return _stack;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



template <class scalar> hamiltonian_t<scalar> & hamiltonian_t<scalar>::operator += (const hamiltonian_t<scalar> param){
  op_add(*this, param);
  return *this;
}
template <class scalar> hamiltonian_t<scalar> & hamiltonian_t<scalar>::operator -= (const hamiltonian_t<scalar> param){
  op_sub(*this, param);
  return *this;
}
template <class scalar> hamiltonian_t<scalar> & hamiltonian_t<scalar>::dot_equals(const hamiltonian_t<scalar> param){
  op_sub(*this, param);
  return *this;
}

template <class scalar> hamiltonian_t<scalar> & hamiltonian_t<scalar>::operator *= (const hamiltonian_t<scalar> param){
  op_mul(*this, param);
  return *this;
}
template <class scalar> hamiltonian_t<scalar> & hamiltonian_t<scalar>::operator /= (const hamiltonian_t<scalar> param){
  op_div(*this, param);
  return *this;
}
template <class scalar> hamiltonian_t<scalar> & hamiltonian_t<scalar>::operator *= (const scalar param) {
  op_mul(*this, param);
  return *this;
}
template <class scalar> hamiltonian_t<scalar> & hamiltonian_t<scalar>::operator /= (const scalar param) {
  op_div(*this, param);
  return *this;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





template <class scalar> bool hamiltonian_t<scalar>::operator == (const hamiltonian_t<scalar> param) const {
  return x==param.x && y==param.y && z==param.z;
}
template <class scalar> bool hamiltonian_t<scalar>::operator != (const hamiltonian_t<scalar> param) const {
  return x!=param.x || y!=param.y || z!=param.z;
}
template <class scalar> bool hamiltonian_t<scalar>::operator <= (const hamiltonian_t<scalar> param) const {
  return (norm2() <= param.norm2());
}
template <class scalar> bool hamiltonian_t<scalar>::operator >= (const hamiltonian_t<scalar> param) const {
  return (norm2() >= param.norm2());
}
template <class scalar> bool hamiltonian_t<scalar>::operator < (const hamiltonian_t<scalar> param) const {
  return (norm2() < param.norm2());
}
template <class scalar> bool hamiltonian_t<scalar>::operator > (const hamiltonian_t<scalar> param) const {
  return (norm2() > param.norm2());
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



template <class scalar> vector_t<scalar> hamiltonian_t<scalar>::vector_cast() {
  vector_t<scalar> _this(&x, 3);
  return _this;
}

template <class scalar> quaternion_t<scalar> hamiltonian_t<scalar>::quaternion_cast() {
  return { x-x, x, y, z };
}

template <class scalar> quaternion_t<scalar> hamiltonian_t<scalar>::quaternion_cast(scalar _re) {
  return { _re, x, y, z };
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



template class complex_t<float>;
template class quaternion_t<float>;
template class hamiltonian_t<float>;

template class ptr_t<void*>;
template class array_t<void*>;

template class ptr_t<complex_t<float>>;
template class array_t<complex_t<float>>;
template class array2d_t<complex_t<float>>;
template class vector_t<complex_t<float>>;
template class matrix_t<complex_t<float>>;

template class ptr_t<quaternion_t<float>>;
template class array_t<quaternion_t<float>>;
template class array2d_t<quaternion_t<float>>;
template class vector_t<quaternion_t<float>>;
template class matrix_t<quaternion_t<float>>;

template class ptr_t<hamiltonian_t<float>>;
template class array_t<hamiltonian_t<float>>;
template class array2d_t<hamiltonian_t<float>>;
template class vector_t<hamiltonian_t<float>>;
template class matrix_t<hamiltonian_t<float>>;

template class ptr_t<matrix_t<float>>;
template class ptr_t<matrix_t<complex_t<float>>>;
template class ptr_t<matrix_t<quaternion_t<float>>>;
template class ptr_t<matrix_t<hamiltonian_t<float>>>;

template class array_t<matrix_t<float>>;
template class array_t<matrix_t<complex_t<float>>>;
template class array_t<matrix_t<quaternion_t<float>>>;
template class array_t<matrix_t<hamiltonian_t<float>>>;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



